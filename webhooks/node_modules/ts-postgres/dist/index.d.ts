// Generated by dts-bundle-generator v9.5.1

import { Buffer } from 'node:buffer';
import { Writable } from 'node:stream';
import { ConnectionOptions } from 'node:tls';

export declare const enum DataType {
	Bool = 16,
	Bytea = 17,
	Char = 18,
	Name = 19,
	Int8 = 20,
	Int2 = 21,
	Int4 = 23,
	Regproc = 24,
	Text = 25,
	Oid = 26,
	Tid = 27,
	Xid = 28,
	Cid = 29,
	PgDdlCommand = 32,
	Json = 114,
	Xml = 142,
	PgNodeTree = 194,
	ArrayJson = 199,
	Smgr = 210,
	IndexAmHandler = 325,
	Point = 600,
	Lseg = 601,
	Path = 602,
	Box = 603,
	Polygon = 604,
	Line = 628,
	Cidr = 650,
	Float4 = 700,
	Float8 = 701,
	Abstime = 702,
	Reltime = 703,
	Tinterval = 704,
	Unknown = 705,
	Circle = 718,
	Macaddr8 = 774,
	Money = 790,
	Macaddr = 829,
	Inet = 869,
	ArrayBytea = 1001,
	ArrayChar = 1002,
	ArrayInt2 = 1005,
	ArrayInt4 = 1007,
	ArrayRegprocedure = 1008,
	ArrayText = 1009,
	ArrayBpchar = 1014,
	ArrayVarchar = 1015,
	ArrayInt8 = 1016,
	ArrayFloat4 = 1021,
	ArrayFloat8 = 1022,
	Aclitem = 1033,
	Bpchar = 1042,
	Varchar = 1043,
	Date = 1082,
	Time = 1083,
	Timestamp = 1114,
	ArrayTimestamp = 1115,
	ArrayDate = 1182,
	Timestamptz = 1184,
	ArrayTimestamptz = 1185,
	Interval = 1186,
	Timetz = 1266,
	Bit = 1560,
	Varbit = 1562,
	Numeric = 1700,
	Refcursor = 1790,
	Regprocedure = 2202,
	Regoper = 2203,
	Regoperator = 2204,
	Regclass = 2205,
	Regtype = 2206,
	Record = 2249,
	Cstring = 2275,
	Any = 2276,
	Anyarray = 2277,
	Void = 2278,
	Trigger = 2279,
	LanguageHandler = 2280,
	Internal = 2281,
	Opaque = 2282,
	AnyElement = 2283,
	AnyNonArray = 2776,
	Uuid = 2950,
	ArrayUuid = 2951,
	TxidSnapshot = 2970,
	FdwHandler = 3115,
	PgLsn = 3220,
	TsmHandler = 3310,
	PgNdistinct = 3361,
	PgDependencies = 3402,
	Anyenum = 3500,
	Tsvector = 3614,
	Tsquery = 3615,
	GtsVector = 3642,
	Regconfig = 3734,
	Regdictionary = 3769,
	Jsonb = 3802,
	ArrayJsonb = 3807,
	Anyrange = 3831,
	EventTrigger = 3838,
	Regnamespace = 4089,
	Regrole = 4096,
	MinUserOid = 16384
}
export declare const enum DataFormat {
	Text = 0,
	Binary = 1
}
export type ValueTypeReader = (buffer: Buffer, start: number, end: number, format: DataFormat, encoding?: BufferEncoding) => any;
export interface Point {
	x: number;
	y: number;
}
export interface QueryOptions {
	/** The query name. */
	readonly name: string;
	/** Whether to use the default portal (i.e. unnamed) or provide a name. */
	readonly portal: string;
	/** Allows making the database native type explicit for some or all columns. */
	readonly types: DataType[];
	/** Whether column data should be transferred using text or binary mode. */
	readonly format: DataFormat | DataFormat[];
	/** A mapping from column name to a socket, e.g. an open file. */
	readonly streams: Record<string, Writable>;
	/** Allows the transformation of column names as returned by the database. */
	readonly transform: (name: string) => string;
	/** Use bigint for the INT8 (64-bit integer) data type. */
	readonly bigints: boolean;
}
/**
 * A query parameter can be used in place of a query text as the first argument
 * to the {@link Client.query} method.
 * @interface
 */
export type Query = Partial<QueryOptions> & {
	text: string;
};
export declare const enum ErrorLevel {
	Debug1 = "DEBUG1",
	Debug2 = "DEBUG2",
	Debug3 = "DEBUG3",
	Debug4 = "DEBUG4",
	Debug5 = "DEBUG5",
	Error = "ERROR",
	Fatal = "FATAL",
	Log = "LOG",
	Notice = "NOTICE",
	Panic = "PANIC"
}
export declare const enum TransactionStatus {
	Idle = 73,
	InTransaction = 84,
	InError = 69
}
export interface ClientConnectionOptions {
	user: string;
	clientEncoding: BufferEncoding;
}
export interface ClientConnectionDefaults {
	database: string;
	clientMinMessages: Uppercase<keyof typeof ErrorLevel>;
	defaultTableAccessMethod: string;
	defaultTablespace: string;
	defaultTransactionIsolation: string;
	extraFloatDigits: number;
	idleInTransactionSessionTimeout: number;
	idleSessionTimeout: number;
	lockTimeout: number;
	searchPath: string;
	statementTimeout: number;
}
export declare class DatabaseError extends Error {
	readonly level: ErrorLevel;
	readonly code: string;
	readonly message: string;
	readonly detail?: string | undefined;
	readonly hint?: string | undefined;
	readonly file?: string | undefined;
	readonly line?: number | undefined;
	readonly routine?: string | undefined;
	readonly position?: number | undefined;
	constructor(level: ErrorLevel, code: string, message: string, detail?: string | undefined, hint?: string | undefined, file?: string | undefined, line?: number | undefined, routine?: string | undefined, position?: number | undefined);
}
export type Resolution = null | string;
export type Callback<T> = (item: T) => void;
export type ResultHandler = (resolve: Callback<Resolution>, reject: Callback<Error | DatabaseError>) => void;
/** The default result type, used if no generic type parameter is specified. */
export type ResultRecord<T = any> = Record<string, T>;
declare class ResultRowImpl<T> extends Array<any> {
	#private;
	set(names: string[], lookup: Map<keyof T, number>, values: any[]): void;
	/**
	 * Return value for the provided column name.
	 */
	get<K extends string & keyof T>(name: keyof T): T[K];
	/**
	 * Return an object mapping column names to values.
	 */
	reify(): T;
}
/**
 * A result row provides access to data for a single row, extending an array.
 * @interface
 *
 * The generic type parameter is carried over from the query method.
 *
 * To retrieve a column value by name use the {@link get} method; or use {@link reify} to convert
 * the row into an object.
 *
 */
export type ResultRow<T> = ReadonlyArray<any> & Pick<ResultRowImpl<T>, "get" | "reify">;
/**
 * The awaited query result.
 *
 * Iterating over the result yields objects of the generic type parameter.
 */
export declare class Result<T = ResultRecord> {
	names: string[];
	rows: ResultRow<T>[];
	status: null | string;
	constructor(names: string[], rows: ResultRow<T>[], status: null | string);
	[Symbol.iterator](): Iterator<T>;
}
declare class ResultIteratorImpl<T> extends Promise<Result<T>> {
	private names;
	private data;
	private subscribers;
	private done;
	constructor(names: string[], data: any[][], executor: ResultHandler);
	/**
	 * Return the first item (if any) from the query results.
	 */
	first(): Promise<T | undefined>;
	/**
	 * Return the first item from the query results, or throw an error.
	 */
	one(): Promise<T>;
	notify(done: boolean, status?: string | DatabaseError | Error): void;
	[Symbol.asyncIterator](): AsyncIterator<T>;
}
export interface ResultIterator<T> extends ResultIteratorImpl<T> {
}
export interface ConnectionInfo {
	encrypted: boolean;
	parameters: ReadonlyMap<string, string>;
}
export interface ClientNotice extends DatabaseError {
}
export interface DataTypeError {
	dataType: DataType;
	value: any;
}
export declare enum SSLMode {
	Disable = "disable",
	Prefer = "prefer",
	Require = "require"
}
export interface SSL {
	mode: SSLMode.Prefer | SSLMode.Require;
	options?: ConnectionOptions;
}
export interface Configuration extends Partial<ClientConnectionDefaults & ClientConnectionOptions> {
	user?: string;
	database?: string;
	host?: string;
	port?: number;
	password?: string;
	types?: Map<DataType, ValueTypeReader>;
	bigints?: boolean;
	keepAlive?: boolean;
	preparedStatementPrefix?: string;
	connectionTimeout?: number;
	ssl?: SSLMode.Disable | SSL;
}
export interface Notification {
	processId: number;
	channel: string;
	payload: string;
}
export interface PreparedStatement<T = ResultRecord> extends AsyncDisposable {
	close: (portal?: string) => Promise<void>;
	execute: (values?: any[], portal?: string, format?: DataFormat | DataFormat[], streams?: Record<string, Writable>) => ResultIterator<T>;
}
export interface EventMap {
	/** The connection has ended, possibly due to a network error. */
	end: [
		NodeJS.ErrnoException | null
	];
	/** A database error has occurred. */
	error: [
		DatabaseError
	];
	/** A client notice (typically a warning) has been received. */
	notice: [
		ClientNotice
	];
	/** A client notification has been received. */
	notification: [
		Notification
	];
}
export type EventListener<K> = K extends keyof EventMap ? ((...args: EventMap[K]) => void) : never;
declare class ClientImpl {
	readonly config: Configuration;
	private readonly events;
	private connected;
	private error;
	private ending?;
	private connecting?;
	private readonly encoding;
	private readonly writer;
	private readonly clientNonce;
	private serverSignature;
	private expect;
	private stream;
	private mustDrain;
	private activeRow;
	private bindQueue;
	private closeHandlerQueue;
	private cleanupQueue;
	private errorHandlerQueue;
	private preFlightQueue;
	private rowDescriptionQueue;
	private parameterDescriptionQueue;
	private nextPreparedStatementId;
	private activeDataHandlerInfo;
	private readonly parameters;
	closed: boolean;
	processId: number | null;
	secretKey: number | null;
	transactionStatus: TransactionStatus | null;
	/**
	 * @param config - An optional configuration object, comprised of connection details
	 *     and client configuration. Most of the connection details can also be specified
	 *     using environment variables, see {@link Environment}.
	 */
	constructor(config?: Configuration);
	private startup;
	private receive;
	connect(): Promise<ConnectionInfo>;
	/** End the database connection.
	 *
	 */
	end(): Promise<void>;
	on<K extends keyof EventMap>(event: K, listener: EventListener<K>): void;
	off<K extends keyof EventMap>(event: K, listener: EventListener<K>): void;
	/** Prepare a statement for later execution.
	 *
	 * @returns A prepared statement object.
	 */
	prepare<T = ResultRecord>(text: Query | string): Promise<PreparedStatement<T>>;
	/**
	 * Send a query to the database.
	 *
	 * The query string is given as the first argument, or pass a {@link Query}
	 * object which provides more control.
	 *
	 * @param text - The query string, or pass a {@link Query}
	 *     object which provides more control (including streaming values into a socket).
	 * @param values - The query parameters, corresponding to $1, $2, etc.
	 * @returns A promise for the query results.
	 */
	query<T = ResultRecord>(text: Query | string, values?: any[]): ResultIterator<T>;
	private bindAndExecute;
	private handleError;
	[Symbol.asyncDispose](): Promise<void>;
	private send;
	private sendUsing;
	private parseError;
	private handle;
}
/** Environment variables providing connection configuration defaults.
 *
 *  See {@link https://www.postgresql.org/docs/current/libpq-envars.html} for a detailed description.
 */
export type Environment = keyof {
	PGCLIENTENCODING: string;
	PGCONNECT_TIMEOUT: string;
	PGDATABASE: string;
	PGHOST: string;
	PGPASSWORD: string;
	PGPORT: string;
	PGSSLMODE: string;
	PGUSER: string;
};
export interface _Client extends ClientImpl {
}
/** A database client, encapsulating a single connection to the database.
 *
 * @interface
 */
export type Client = Omit<_Client, "connect"> & ConnectionInfo;
/** Connect to the database.
 *
 * @remarks
 * You must close the connection after use using {@link Client.end} to close
 * open handles.
 *
 * @returns A database client, with an active connection.
 */
export declare function connect(config?: Configuration): Promise<Client>;

export {};
